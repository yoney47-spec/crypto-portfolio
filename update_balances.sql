-- 1. Create Balances Table
CREATE TABLE IF NOT EXISTS balances (
    id bigint generated by default as identity primary key,
    asset_id bigint references assets(id) on delete cascade not null,
    amount numeric not null default 0,
    updated_at timestamp with time zone default timezone('utc'::text, now()) not null,
    unique(asset_id)
);

ALTER TABLE balances ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Enable all for anon" ON balances FOR ALL USING (true) WITH CHECK (true);

-- 2. Create Function to Update Balance
CREATE OR REPLACE FUNCTION update_balance_on_transaction()
RETURNS TRIGGER AS $$
BEGIN
    -- If INSERT
    IF (TG_OP = 'INSERT') THEN
        INSERT INTO balances (asset_id, amount)
        VALUES (
            NEW.asset_id,
            CASE
                WHEN NEW.type IN ('Buy', 'Airdrop', 'Staking Reward', 'Interest', 'Gift') THEN NEW.quantity
                WHEN NEW.type IN ('Sell', 'Transfer') THEN -NEW.quantity
                ELSE 0
            END
        )
        ON CONFLICT (asset_id) DO UPDATE SET
            amount = balances.amount + EXCLUDED.amount,
            updated_at = now();
        RETURN NEW;
    -- If DELETE
    ELSIF (TG_OP = 'DELETE') THEN
        UPDATE balances
        SET amount = amount - (
            CASE
                WHEN OLD.type IN ('Buy', 'Airdrop', 'Staking Reward', 'Interest', 'Gift') THEN OLD.quantity
                WHEN OLD.type IN ('Sell', 'Transfer') THEN -OLD.quantity
                ELSE 0
            END
        ),
        updated_at = now()
        WHERE asset_id = OLD.asset_id;
        RETURN OLD;
    -- If UPDATE
    ELSIF (TG_OP = 'UPDATE') THEN
        -- Revert OLD
        UPDATE balances
        SET amount = amount - (
            CASE
                WHEN OLD.type IN ('Buy', 'Airdrop', 'Staking Reward', 'Interest', 'Gift') THEN OLD.quantity
                WHEN OLD.type IN ('Sell', 'Transfer') THEN -OLD.quantity
                ELSE 0
            END
        )
        WHERE asset_id = OLD.asset_id;
        
        -- Apply NEW
        INSERT INTO balances (asset_id, amount)
        VALUES (
            NEW.asset_id,
            CASE
                WHEN NEW.type IN ('Buy', 'Airdrop', 'Staking Reward', 'Interest', 'Gift') THEN NEW.quantity
                WHEN NEW.type IN ('Sell', 'Transfer') THEN -NEW.quantity
                ELSE 0
            END
        )
        ON CONFLICT (asset_id) DO UPDATE SET
            amount = balances.amount + EXCLUDED.amount,
            updated_at = now();
        RETURN NEW;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- 3. Create Trigger
DROP TRIGGER IF EXISTS on_transaction_change ON transactions;
CREATE TRIGGER on_transaction_change
AFTER INSERT OR UPDATE OR DELETE ON transactions
FOR EACH ROW EXECUTE FUNCTION update_balance_on_transaction();

-- 4. Initial Population
-- Calculate current balances from transactions and insert/update balances table
DO $$
DECLARE
    r RECORD;
BEGIN
    -- Clear existing (optional, but safer to recalculate)
    -- TRUNCATE TABLE balances; -- Don't truncate if we want to keep IDs, just upsert.
    
    FOR r IN SELECT asset_id, SUM(
        CASE
            WHEN type IN ('Buy', 'Airdrop', 'Staking Reward', 'Interest', 'Gift') THEN quantity
            WHEN type IN ('Sell', 'Transfer') THEN -quantity
            ELSE 0
        END
    ) as total FROM transactions GROUP BY asset_id
    LOOP
        INSERT INTO balances (asset_id, amount) 
        VALUES (r.asset_id, r.total)
        ON CONFLICT (asset_id) DO UPDATE SET
            amount = r.total,
            updated_at = now();
    END LOOP;
END $$;
